,PostId,ParentId,PostTypeId,EventId,Event,UserName,CreationDate,Tags,Score,Text
0,35666,35002,2,914779,Comment,Sarah Vessels,2009-07-08 19:23:17.147,,1,"A few errors:  you need 'new ' in front of all `InvalidOperationException()`, it should be `public bool Contains(TKey item)`, and `CopyTo` needs no `return`."
1,35666,35002,2,914786,Comment,Sarah Vessels,2009-07-08 19:24:45.943,,0,"Whoops, instead of changing the parameter type in `Contains`, change its body to use `Contains` instead of `ContainsKey`:  `return _dict.Contains(item);`"
2,35666,35002,2,915553,Comment,dbkk,2009-07-08 22:01:12.087,,0,"@Sarah, thank you."
3,35666,35002,2,1269039,Comment,Elazar Leibovich,2009-09-15 06:01:20.317,,3,"You did not implement equality check, which is a very important feature for immutable data structures."
4,35666,35002,2,2395815,Comment,Richard Berg,2010-03-10 03:42:08.963,,2,"Looks like all you did is take a standard Dictionary and throw exceptions all over the place...?  ""Immutable"" doesn't have to mean ""useless.""  Quite the contrary."
5,35666,35002,2,2434531,Comment,dbkk,2010-03-15 14:06:21.027,,0,"@Richard. Why is enforcing immutability useless? ReadOnlyCollection does a similar thing. What would you do in place of throwing exceptions? Provide an alternative solution, saying ""the contrary"" is insufficient."
6,35666,35002,2,2435782,Comment,Richard Berg,2010-03-15 16:28:31.157,,0,Something like a Bit-Partitioned Hash Trie would provide immutability without completely compromising the ADT as you've done.  Your class claims to implement IDictionary<T> but frankly it's lying.  Just because the compiler lets you get away with something doesn't make it right.
7,35666,35002,2,2814365,Comment,chiccodoro,2010-05-06 08:27:42.787,,0,"@Richard. AFAIK dbkk's way is quite a ""standard"" way to provide immutable collections, in c# as well as in java: They provide the same interface with the only difference that some methods throw exceptions. This way, if a method requires a dictionary or a list, it can be provided with these immutable objects because the interface matches."
8,35666,35002,2,2845925,Comment,Richard Berg,2010-05-11 02:04:50.093,,0,"No reason why a BPHT couldn't implement IDictionary.  Or for something simple & elegant, just scroll down to Serhat's answer.  It's preposterous that a highly instructive blog series from C# designer Eric Lippert has 2.5X fewer votes than this cop-out."
9,35666,35002,2,3336089,Comment,Michael Stum,2010-07-12 19:47:31.920,,0,@Richard Honest Question: What would an immutable collection do if you call Add to it? You can't get rid of the Add function as you then don't have an IDictionary anymore. Should it silently fail?
10,35666,35002,2,3338734,Comment,Richard Berg,2010-07-13 03:11:15.500,,0,"No, of course not.  Did you even read the answer?  Here, I'll link it again: http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx"
11,35666,35002,2,3866874,Comment,Egor,2010-09-09 01:09:19.393,,6,"So much rancor here, when the poster clearly meant ""Read-Only"" rather than ""Immutable"". I think this wrapper probably fit his needs, hence the high score. I'm glad people came out and got a bit more theoretical, but let's not lose sight of what the OP actually needed."
12,35666,35002,2,3998673,Comment,Stefan Monov,2010-09-23 08:49:13.287,,1,"@dbkk: I don't like that your solution violates the substitution-principle. I wouldn't derive from IDictionary. I would keep an IDictionary private member, and forward all non-mutating calls to it, and I wouldn't provide forwarding methods for the mutating calls. That way it's safe at compile time. Yes, then it's not usable as an IDictionary or ICollection, but that's exactly the point."
13,35666,35002,2,3998697,Comment,Stefan Monov,2010-09-23 08:51:58.150,,13,"@Everyone else: In case you're wondering like I was, it seems some people make a difference between ""Read-Only"" and ""Immutable"". An ""immutable"" dictionary can have an Add method that *returns* a new dictionary with the element added to it, whereas a ""read-only"" one doesn't, and the only way to get a useful instance of a ""read-only"" dictionary is to build a normal Dictionary, and then construct a ""read-only"" wrapper for it."
14,35666,35002,2,3998709,Comment,Stefan Monov,2010-09-23 08:53:43.497,,0,"My comment to dbkk suggests a better way to create a *read-only* dictionary, but doesn't address the ""immutable dictionary"" problem. This one is addressed by Eric Lippert in Richard's last link. Note that Lippert goes the extra mile - not only does he provide an non-mutating Add method, but it does so *efficiently*, by never copying data that doesn't need to be copied."
15,35666,35002,2,6173743,Comment,Joren,2011-03-27 12:55:17.110,,4,"@Stefan: The distinction as I see it is not in whether there's any way to construct a new collection from an existing one. A collection like the one in this answer has a read-only interface: anyone who is passed an instance of this can not modify it, but it is not guaranteed that *no one* can modify it. (Someone with the original `backingDict` could modify the collection.) Immutable collections, on the other hand, are guaranteed not to be modified by anyone."
16,35666,35002,2,7811198,Comment,James Michael Hare,2011-07-07 20:43:52.927,,2,"It's funny how vitriolic people are in this answer, when this answer does no more or no less than C#'s own ReadOnlyCollection does, except that it support IDictionary<TKey,TValue> instead of IList<T>."
17,35666,35002,2,9028463,Comment,szogun1987,2011-09-18 15:56:15.647,,0,"@Stefan have right. Constructor should containst like this: _dict = new Dictionary<TKey, TValue>(backingDict);"
18,35666,35002,2,12149995,Comment,chakrit,2012-03-06 10:17:22.900,,1,"Why don't you guys just edit the answer and add your ""missing"" or ""immutable"" requirements in?"
19,35666,35002,2,29557077,Comment,nawfal,2013-11-08 23:53:06.127,,0,"`throw`ing under `Add`, `Remove`, `Clear` etc are fine, but kindly make those implementations explicit, so that its not so obvious."
