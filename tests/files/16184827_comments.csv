,PostId,ParentId,PostTypeId,EventId,Event,UserName,CreationDate,Tags,Score,Text
0,16184827,11227809,2,23161186,Comment,Dustin Oprea,2013-04-24 17:50:33.540,,46,"You want to bypass the branch-predictor, why? It's an optimization."
1,16184827,11227809,2,23168606,Comment,atlaste,2013-04-24 21:57:13.867,,90,"Because no branch is better than a branch :-) In a lot of situations this is simply a lot faster... if you're optimizing, it's definitely worth a try. They also use it quite a bit in f.ex. http://graphics.stanford.edu/~seander/bithacks.html"
2,16184827,11227809,2,30989994,Comment,Zain Rizvi,2013-12-19 21:45:03.287,,25,"In general lookup tables can be fast, but have you ran the tests for this particular condition? You'll still have a branch condition in your code, only now it's moved to the look up table generation part.  You still wouldn't get your perf boost"
3,16184827,11227809,2,31021845,Comment,atlaste,2013-12-20 18:57:29.683,,26,"@Zain if you really want to know... Yes: 15 seconds with the branch and 10 with my version. Regardless, it's a useful technique to know either way."
4,16184827,11227809,2,33971695,Comment,Kris Vandermotten,2014-03-12 12:17:49.593,,32,"Why not `sum += lookup[data[j]]` where `lookup` is an array with 256 entries, the first ones being zero and the last ones being equal to the index?"
5,16184827,11227809,2,34147763,Comment,atlaste,2014-03-17 10:24:45.547,,0,@KrisVandermotten +1 for that - I made a bug implementing it by checking the index of j; it should have been `lookup[data[j]]` as you suggest instead.
6,16184827,11227809,2,34163618,Comment,Kris Vandermotten,2014-03-17 17:17:02.867,,1,"You say ""There has been quite some work on eliminating this branch for managed languages."" Sure, but that won't help with `sum += lookup[data[j]];`. However, what will help is that the lookup will never go out of bounds in a bug free program, so the branch predictor can predict the branch perfectly. And that means speed!"
7,16184827,11227809,2,34186122,Comment,atlaste,2014-03-18 08:33:51.967,,0,"@KrisVandermotten Yes, that's correct. What would also help in this case is use the correct data type (e.g. `byte[] data`); that would eliminate the branch completely, which means more speed. :-) Basically I always assume that if (1) you're in a tight loop with a limited amount of code (such as here) and (2) if you could predict the branches with 'static code analysis', then the processor / JIT'ter will do their work properly."
8,16184827,11227809,2,54496004,Comment,A. Binzxxxxxx,2015-10-26 16:06:42.273,,0,array access means pointer operation like *(ptr + x) - right? tannery operator should be faster here - right?
9,16184827,11227809,2,61960861,Comment,Chinaxing,2016-05-13 16:15:48.537,,0,"but the lookup method will need the jump instruction to jump to the target codes. this place have the unconditional jump, the cpu will always clean its pipeline in this case ? which will be bad than if prediction when the prediction hit. is this right?"
