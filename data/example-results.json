["{\"Tangled\": \"\", \"Comment\": \"Sure, I know these methods. But they only allow to do UI Changes **before** or **after** the task ran. `onProgressUpdate()`can be uses **during** the execution but regarding to the docu it is not guranteed when this method will run. The background thread will continue its work and not wait for `onProgressUpdate()` to return. But this is what I am looking for. Thus in this special case these methods does not help, do they?\", \"Answer Id\": 24548749, \"Confirmed\": \"1\", \"Tags\": \" <java><android><multithreading><android-asynct...\", \"After\": [\"    public class TestTask extends AsyncTask{\\n        private boolean intermediary;\\n        @Override\\n        protected Object doInBackground(Object... arg0) {\\n            Log.d(\\\"First\\\", \\\"First\\\");\\n            onProgressUpdate(null);\\n            while(!intermediary){ try{Thread.sleep(1000);} catch(Exception e){} }\\n            Log.d(\\\"Second\\\", \\\"Second\\\");\\n            return null;\\n        }\\n        @Override \\n        protected void onProgressUpdate(Object... args){       \\n            // Check stuff on the UI\\n            intermediary = true;\\n        }\\n    }\"], \"Category\": \"\", \"Question Id\": 24548624, \"Comment Id\": 38018547, \"Edit Id\": 68570698, \"Useful\": \"0\", \"Before\": []}", "{\"Tangled\": \"\", \"Comment\": \"Thanks. Please have a look at my EDIT. Splitting up the process in multiple AsyncTasks could solve the problem but I think it would not be a very nice solution. Additionally the primary question is why `wait()`does not work as expected and not how to circumvent the fact that it does not :)\", \"Answer Id\": 24548749, \"Confirmed\": \"1\", \"Tags\": \" <java><android><multithreading><android-asynct...\", \"After\": [\"    public class TestTask extends AsyncTask{\\n        private boolean intermediary;\\n        @Override\\n        protected Object doInBackground(Object... arg0) {\\n            Log.d(\\\"First\\\", \\\"First\\\");\\n            onProgressUpdate(null);\\n            while(!intermediary){ try{Thread.sleep(1000);} catch(Exception e){} }\\n            Log.d(\\\"Second\\\", \\\"Second\\\");\\n            return null;\\n        }\\n        @Override \\n        protected void onProgressUpdate(Object... args){       \\n            // Check stuff on the UI\\n            intermediary = true;\\n        }\\n    }\"], \"Category\": \"\", \"Question Id\": 24548624, \"Comment Id\": 38018926, \"Edit Id\": 68570698, \"Useful\": \"0\", \"Before\": []}", "{\"Tangled\": \"\", \"Comment\": \"Thank you very much for your help! Constructing a wait using while loop could work I think. I will try that. However this would be a hack and not a real solution. Any idea what `wait()` does not work as expected? Is this a bug in `wait()`or in my expectations?\", \"Answer Id\": 24548749, \"Confirmed\": \"1\", \"Tags\": \" <java><android><multithreading><android-asynct...\", \"After\": [\"    public class TestTask extends AsyncTask{\\n        \\n        private boolean notified;\\n        private Promptable p;\\n        public interface Promptable { public abstract void prompt(); }\\n        public TestTask(Promptable p){\\n            this.p = p;\\n        }\\n        @Override\\n        protected Object doInBackground(Object... arg0) {\\n            Log.d(\\\"First\\\", \\\"First\\\");\\n            onProgressUpdate(null);\\n            synchronized(this){\\n                while(!notified){\\n                    try{\\n                        this.wait();\\n                    }\\n                    catch(InterruptedException e){\\n                        // Handle Exception\\n                    }                    \\n                }\\n            }\\n            Log.d(\\\"Second\\\", \\\"Second\\\");\\n            return null;\\n        }\\n        @Override \\n        protected void onProgressUpdate(Object... args){       \\n            synchronized(this){\\n                notified = true;\\n                p.prompt();               \\n                this.notify();\\n            }\\n        }\\n    }\"], \"Category\": \"\", \"Question Id\": 24548624, \"Comment Id\": 38019634, \"Edit Id\": 68571896, \"Useful\": \"0\", \"Before\": []}", "{\"Tangled\": \"\", \"Comment\": \"by calling Thread.sleep() aren't you blocking the entire thread running AsyncTasks ?  This may affect other AsyncTasks unless of course there are none.\", \"Answer Id\": 24548749, \"Confirmed\": \"1\", \"Tags\": \" <java><android><multithreading><android-asynct...\", \"After\": [], \"Category\": \"\", \"Question Id\": 24548624, \"Comment Id\": 75658099, \"Edit Id\": 148599879, \"Useful\": \"1\", \"Before\": [\"    public class TestTask extends AsyncTask{\\n        private boolean finished;\\n        @Override\\n        protected Object doInBackground(Object... args) {\\n            Log.d(\\\"First\\\", \\\"First\\\");\\n            onProgressUpdate(null);\\n            while(!finished){\\n                try{\\n                    Thread.sleep(1000);\\n                } catch(InterruptedException e) { }\\n            }\\n            Log.d(\\\"Second\\\", \\\"Second\\\");\\n            return null;\\n        }\\n        @Override \\n        protected void onProgressUpdate(Object... args){       \\n            // Check stuff on the UI\\n            finished = true;\\n        }\\n    }\"]}"]
